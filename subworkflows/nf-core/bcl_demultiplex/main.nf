#!/usr/bin/env nextflow

//
// Demultiplex Illumina BCL data using bcl-convert or bcl2fastq
//

include { BCLCONVERT } from "../../../modules/nf-core/bclconvert/main"
include { BCL2FASTQ  } from "../../../modules/nf-core/bcl2fastq/main"

// Initialize an empty channel to collect paths of invalid FASTQ files
invalid_fastqs_ch = Channel.empty()

workflow BCL_DEMULTIPLEX {
    take:
        ch_flowcell     // [[id:"", lane:""],samplesheet.csv, path/to/bcl/files]
        demultiplexer   // bclconvert or bcl2fastq

    main:
        ch_versions = Channel.empty()
        ch_fastq    = Channel.empty()
        ch_reports  = Channel.empty()
        ch_stats    = Channel.empty()
        ch_interop  = Channel.empty()

        // Split flowcells into separate channels containg run as tar and run as path
        // https://nextflow.slack.com/archives/C02T98A23U7/p1650963988498929
        ch_flowcell
            .branch { meta, samplesheet, run ->
                tar: run.toString().endsWith(".tar.gz")
                dir: true
            }.set { ch_flowcells }

        ch_flowcells.tar
            .multiMap { meta, samplesheet, run ->
                samplesheets: [ meta, samplesheet ]
                run_dirs: [ meta, run ]
            }.set { ch_flowcells_tar }

        // Runs when run_dir is a tar archive
        // Re-join the metadata and the untarred run directory with the samplesheet
        ch_flowcells_tar_merged = ch_flowcells_tar.samplesheets.join( ch_flowcells_tar.run_dirs )

        // Merge the two channels back together
        ch_flowcells = ch_flowcells.dir.mix(ch_flowcells_tar_merged)

        // MODULE: bclconvert
        // Demultiplex the bcl files
        if (demultiplexer == "bclconvert") {
            BCLCONVERT( ch_flowcells )
            ch_fastq    = ch_fastq.mix(BCLCONVERT.out.fastq)
            ch_interop  = ch_interop.mix(BCLCONVERT.out.interop)
            ch_reports  = ch_reports.mix(BCLCONVERT.out.reports)
            ch_versions = ch_versions.mix(BCLCONVERT.out.versions)
        }

        // MODULE: bcl2fastq
        // Demultiplex the bcl files
        if (demultiplexer == "bcl2fastq") {
            BCL2FASTQ( ch_flowcells )
            ch_fastq    = ch_fastq.mix(BCL2FASTQ.out.fastq)
            ch_interop  = ch_interop.mix(BCL2FASTQ.out.interop)
            ch_reports  = ch_reports.mix(BCL2FASTQ.out.reports)
            ch_stats    = ch_stats.mix(BCL2FASTQ.out.stats)
            ch_versions = ch_versions.mix(BCL2FASTQ.out.versions)
        }

        // Generate meta for each fastq
        ch_fastq_with_meta = generate_fastq_meta(ch_fastq)

    emit:
        fastq    = ch_fastq_with_meta
        reports  = ch_reports
        stats    = ch_stats
        interop  = ch_interop
        versions = ch_versions
}

// Collect invalid FASTQ files
invalid_fastqs_ch
    .map { path -> return path.toString() }
    .collectFile(name: 'invalid_fastqs.txt', newLine: true)
    .set { ch_invalid_fastqs_file }

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    FUNCTIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

// Add meta values to fastq channel and filter out invalid FASTQ files
def generate_fastq_meta(ch_reads) {
    ch_reads.flatMap { fc_meta, fastq ->
        try {
            def readgroup = readgroup_from_fastq(fastq)
            if (!readgroup) {
                println("DEBUG: Invalid FASTQ file skipped: ${fastq}")
                return [] // Skip invalid file
            }

            def meta = [
                "id": fastq.getSimpleName().toString() - ~/_R[0-9]_001.*$/,
                "samplename": fastq.getSimpleName().toString() - ~/_S[0-9]+.*$/,
                "readgroup": readgroup,
                "fcid": fc_meta.id,
                "lane": fc_meta.lane
            ]
            meta.readgroup.SM = meta.samplename

            println("DEBUG: Processing file ${fastq} with metadata: ${meta}")
            return [meta, fastq]
        } catch (Exception e) {
            println("DEBUG: Error processing file ${fastq}: ${e.message}")
            return [] // Skip file on error
        }
    }
    .groupTuple(by: [0])
    .map { meta, fastq ->
        meta.single_end = fastq.size() == 1
        println("DEBUG: Grouped metadata: ${meta}, Number of FASTQ files: ${fastq.size()}")
        return [meta, fastq.flatten()]
    }
}

// Add meta values to fastq channel
def generate_fastq_meta(ch_reads) {
    // Create a tuple with the meta.id and the fastq
    ch_reads.transpose().map{
        fc_meta, fastq ->
        def meta = [
            "id": fastq.getSimpleName().toString() - ~/_R[0-9]_001.*$/,
            "samplename": fastq.getSimpleName().toString() - ~/_S[0-9]+.*$/,
            "readgroup": [:],
            "fcid": fc_meta.id,
            "lane": fc_meta.lane
        ]
        meta.readgroup = readgroup_from_fastq(fastq)
        meta.readgroup.SM = meta.samplename

        return [ meta , fastq ]
    }
    // Group by meta.id for PE samples
    .groupTuple(by: [0])
    // Add meta.single_end
    .map {
        meta, fastq ->
        if (fastq.size() == 1){
            meta.single_end = true
        } else {
            meta.single_end = false
        }
        return [ meta, fastq.flatten() ]
    }
}

// https://github.com/nf-core/sarek/blob/7ba61bde8e4f3b1932118993c766ed33b5da465e/workflows/sarek.nf#L1014-L1040
// Function to read the first line of a FASTQ file and extract read group information
def readgroup_from_fastq(path) {
    def line

    try {
        path.withInputStream {
            InputStream gzipStream = new java.util.zip.GZIPInputStream(it)
            Reader decoder = new InputStreamReader(gzipStream, 'ASCII')
            BufferedReader buffered = new BufferedReader(decoder)
            line = buffered.readLine()
        }

        if (line == null || !line.startsWith('@')) {
            invalid_fastqs_ch << path
            println("Warning! Skipping file: ${path}.\n" +
                    "Expected a FASTQ file starting with '@', but found null.\n" +
                    "File is likely empty, corrupt or inaccessible.\n" +
                    "It will be skipped from further analyses.")
            println("To investigate, the FASTQ path will be logged into: ${System.getProperty('user.dir')}/invalid_fastqs.txt")
            return null  // Signal to skip this file and gracefully continue
        }

        line = line.substring(1)
        def fields = line.split(':')
        if (fields.length < 7) {
            invalid_fastqs_ch << path
            println("Warning! File ${path} does not match the expected schema for " +
                    "Illumina's FASTQ headers. It will be skipped from further analyses.\n" +
                    "Expected format: @INSTRUMENT:RUN_NUMBER:FLOWCELL_ID:LANE:TITLE:X_POS:Y_POS")
            println("To investigate, the FASTQ path will be logged into: ${System.getProperty('user.dir')}/invalid_fastqs.txt")
            return null  // Signal to skip this file and gracefully continue
        }

        def sequencer_serial = fields[0]
        def run_number       = fields[1]
        def fcid             = fields[2]
        def lane             = fields[3]
        def index            = fields[-1] =~ /[GATC+-]/ ? fields[-1] : ""

        def rg = [:]
        rg.ID = [fcid, lane].join(".")
        rg.PU = [fcid, lane, index].findAll().join(".")
        rg.PL = "ILLUMINA"

        return rg

    } catch (Exception e) {
        invalid_fastqs_ch << path
        throw new RuntimeException(
                "Critical Error! Processing file ${path} failed: ${e.message}.\n" +
                "Ensure the file is in the correct FASTQ format.", e
        )
    }
}
